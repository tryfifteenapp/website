{"version":3,"sources":["../src/server.ts","../src/util.ts","../src/stream-transport.ts"],"sourcesContent":["import { Server } from '@modelcontextprotocol/sdk/server/index.js';\nimport {\n  CallToolRequestSchema,\n  ListResourcesRequestSchema,\n  ListResourceTemplatesRequestSchema,\n  ListToolsRequestSchema,\n  ReadResourceRequestSchema,\n  type ClientCapabilities,\n  type Implementation,\n  type ListResourcesResult,\n  type ListResourceTemplatesResult,\n  type ReadResourceResult,\n  type ServerCapabilities,\n} from '@modelcontextprotocol/sdk/types.js';\nimport type { z } from 'zod';\nimport zodToJsonSchema from 'zod-to-json-schema';\nimport type {\n  ExpandRecursively,\n  ExtractNotification,\n  ExtractParams,\n  ExtractRequest,\n  ExtractResult,\n} from './types.js';\nimport { assertValidUri, compareUris, matchUriTemplate } from './util.js';\n\nexport type Scheme = string;\n\nexport type Resource<Uri extends string = string, Result = unknown> = {\n  uri: Uri;\n  name: string;\n  description?: string;\n  mimeType?: string;\n  read(uri: `${Scheme}://${Uri}`): Promise<Result>;\n};\n\nexport type ResourceTemplate<Uri extends string = string, Result = unknown> = {\n  uriTemplate: Uri;\n  name: string;\n  description?: string;\n  mimeType?: string;\n  read(\n    uri: `${Scheme}://${Uri}`,\n    params: {\n      [Param in ExtractParams<Uri>]: string;\n    }\n  ): Promise<Result>;\n};\n\nexport type Tool<\n  Params extends z.ZodObject<any> = z.ZodObject<any>,\n  Result = unknown,\n> = {\n  description: string;\n  parameters: Params;\n  execute(params: z.infer<Params>): Promise<Result>;\n};\n\n/**\n * Helper function to define an MCP resource while preserving type information.\n */\nexport function resource<Uri extends string, Result>(\n  uri: Uri,\n  resource: Omit<Resource<Uri, Result>, 'uri'>\n): Resource<Uri, Result> {\n  return {\n    uri,\n    ...resource,\n  };\n}\n\n/**\n * Helper function to define an MCP resource with a URI template while preserving type information.\n */\nexport function resourceTemplate<Uri extends string, Result>(\n  uriTemplate: Uri,\n  resource: Omit<ResourceTemplate<Uri, Result>, 'uriTemplate'>\n): ResourceTemplate<Uri, Result> {\n  return {\n    uriTemplate,\n    ...resource,\n  };\n}\n\n/**\n * Helper function to define a JSON resource while preserving type information.\n */\nexport function jsonResource<Uri extends string, Result>(\n  uri: Uri,\n  resource: Omit<Resource<Uri, Result>, 'uri' | 'mimeType'>\n): Resource<Uri, Result> {\n  return {\n    uri,\n    mimeType: 'application/json' as const,\n    ...resource,\n  };\n}\n\n/**\n * Helper function to define a JSON resource with a URI template while preserving type information.\n */\nexport function jsonResourceTemplate<Uri extends string, Result>(\n  uriTemplate: Uri,\n  resource: Omit<ResourceTemplate<Uri, Result>, 'uriTemplate' | 'mimeType'>\n): ResourceTemplate<Uri, Result> {\n  return {\n    uriTemplate,\n    mimeType: 'application/json' as const,\n    ...resource,\n  };\n}\n\n/**\n * Helper function to define a list of resources that share a common URI scheme.\n */\nexport function resources<Scheme extends string>(\n  scheme: Scheme,\n  resources: (Resource | ResourceTemplate)[]\n): (\n  | Resource<`${Scheme}://${string}`>\n  | ResourceTemplate<`${Scheme}://${string}`>\n)[] {\n  return resources.map((resource) => {\n    if ('uri' in resource) {\n      const url = new URL(resource.uri, `${scheme}://`);\n      const uri = decodeURI(url.href) as `${Scheme}://${typeof resource.uri}`;\n\n      return {\n        ...resource,\n        uri,\n      };\n    }\n\n    const url = new URL(resource.uriTemplate, `${scheme}://`);\n    const uriTemplate = decodeURI(\n      url.href\n    ) as `${Scheme}://${typeof resource.uriTemplate}`;\n\n    return {\n      ...resource,\n      uriTemplate,\n    };\n  });\n}\n\n/**\n * Helper function to create a JSON resource response.\n */\nexport function jsonResourceResponse<Uri extends string, Response>(\n  uri: Uri,\n  response: Response\n) {\n  return {\n    uri,\n    mimeType: 'application/json',\n    text: JSON.stringify(response),\n  };\n}\n\n/**\n * Helper function to define an MCP tool while preserving type information.\n */\nexport function tool<Params extends z.ZodObject<any>, Result>(\n  tool: Tool<Params, Result>\n) {\n  return tool;\n}\n\nexport type InitData = {\n  clientInfo: Implementation;\n  clientCapabilities: ClientCapabilities;\n};\n\nexport type InitCallback = (initData: InitData) => void | Promise<void>;\nexport type PropCallback<T> = () => T | Promise<T>;\nexport type Prop<T> = T | PropCallback<T>;\n\nexport type McpServerOptions = {\n  /**\n   * The name of the MCP server. This will be sent to the client as part of\n   * the initialization process.\n   */\n  name: string;\n\n  /**\n   * The version of the MCP server. This will be sent to the client as part of\n   * the initialization process.\n   */\n  version: string;\n\n  /**\n   * Callback for when initialization has fully completed with the client.\n   */\n  onInitialize?: InitCallback;\n\n  /**\n   * Resources to be served by the server. These can be defined as a static\n   * object or as a function that dynamically returns the object synchronously\n   * or asynchronously.\n   *\n   * If defined as a function, the function will be called whenever the client\n   * asks for the list of resources or reads a resource. This allows for dynamic\n   * resources that can change after the server has started.\n   */\n  resources?: Prop<\n    (Resource<string, unknown> | ResourceTemplate<string, unknown>)[]\n  >;\n\n  /**\n   * Tools to be served by the server. These can be defined as a static object\n   * or as a function that dynamically returns the object synchronously or\n   * asynchronously.\n   *\n   * If defined as a function, the function will be called whenever the client\n   * asks for the list of tools or invokes a tool. This allows for dynamic tools\n   * that can change after the server has started.\n   */\n  tools?: Prop<Record<string, Tool>>;\n};\n\n/**\n * Creates an MCP server with the given options.\n *\n * Simplifies the process of creating an MCP server by providing a high-level\n * API for defining resources and tools.\n */\nexport function createMcpServer(options: McpServerOptions) {\n  const capabilities: ServerCapabilities = {};\n\n  if (options.resources) {\n    capabilities.resources = {};\n  }\n\n  if (options.tools) {\n    capabilities.tools = {};\n  }\n\n  const server = new Server(\n    {\n      name: options.name,\n      version: options.version,\n    },\n    {\n      capabilities,\n    }\n  );\n\n  async function getResources() {\n    if (!options.resources) {\n      throw new Error('resources not available');\n    }\n\n    return typeof options.resources === 'function'\n      ? await options.resources()\n      : options.resources;\n  }\n\n  async function getTools() {\n    if (!options.tools) {\n      throw new Error('tools not available');\n    }\n\n    return typeof options.tools === 'function'\n      ? await options.tools()\n      : options.tools;\n  }\n\n  server.oninitialized = async () => {\n    const clientInfo = server.getClientVersion();\n    const clientCapabilities = server.getClientCapabilities();\n\n    if (!clientInfo) {\n      throw new Error('client info not available after initialization');\n    }\n\n    if (!clientCapabilities) {\n      throw new Error('client capabilities not available after initialization');\n    }\n\n    const initData: InitData = {\n      clientInfo,\n      clientCapabilities,\n    };\n\n    await options.onInitialize?.(initData);\n  };\n\n  if (options.resources) {\n    server.setRequestHandler(\n      ListResourcesRequestSchema,\n      async (): Promise<ListResourcesResult> => {\n        const allResources = await getResources();\n        return {\n          resources: allResources\n            .filter((resource) => 'uri' in resource)\n            .map(({ uri, name, description, mimeType }) => {\n              return {\n                uri,\n                name,\n                description,\n                mimeType,\n              };\n            }),\n        };\n      }\n    );\n\n    server.setRequestHandler(\n      ListResourceTemplatesRequestSchema,\n      async (): Promise<ListResourceTemplatesResult> => {\n        const allResources = await getResources();\n        return {\n          resourceTemplates: allResources\n            .filter((resource) => 'uriTemplate' in resource)\n            .map(({ uriTemplate, name, description, mimeType }) => {\n              return {\n                uriTemplate,\n                name,\n                description,\n                mimeType,\n              };\n            }),\n        };\n      }\n    );\n\n    server.setRequestHandler(\n      ReadResourceRequestSchema,\n      async (request): Promise<ReadResourceResult> => {\n        try {\n          const allResources = await getResources();\n          const { uri } = request.params;\n\n          const resources = allResources.filter(\n            (resource) => 'uri' in resource\n          );\n          const resource = resources.find((resource) =>\n            compareUris(resource.uri, uri)\n          );\n\n          if (resource) {\n            const result = await resource.read(uri as `${string}://${string}`);\n\n            const contents = Array.isArray(result) ? result : [result];\n\n            return {\n              contents,\n            };\n          }\n\n          const resourceTemplates = allResources.filter(\n            (resource) => 'uriTemplate' in resource\n          );\n          const resourceTemplateUris = resourceTemplates.map(\n            ({ uriTemplate }) => assertValidUri(uriTemplate)\n          );\n\n          const templateMatch = matchUriTemplate(uri, resourceTemplateUris);\n\n          if (!templateMatch) {\n            throw new Error('resource not found');\n          }\n\n          const resourceTemplate = resourceTemplates.find(\n            (r) => r.uriTemplate === templateMatch.uri\n          );\n\n          if (!resourceTemplate) {\n            throw new Error('resource not found');\n          }\n\n          const result = await resourceTemplate.read(\n            uri as `${string}://${string}`,\n            templateMatch.params\n          );\n\n          const contents = Array.isArray(result) ? result : [result];\n\n          return {\n            contents,\n          };\n        } catch (error) {\n          return {\n            isError: true,\n            content: [\n              {\n                type: 'text',\n                text: JSON.stringify({ error: enumerateError(error) }),\n              },\n            ],\n          } as any;\n        }\n      }\n    );\n  }\n\n  if (options.tools) {\n    server.setRequestHandler(ListToolsRequestSchema, async () => {\n      const tools = await getTools();\n      return {\n        tools: Object.entries(tools).map(\n          ([name, { description, parameters }]) => {\n            return {\n              name,\n              description,\n              inputSchema: zodToJsonSchema(parameters),\n            };\n          }\n        ),\n      };\n    });\n\n    server.setRequestHandler(CallToolRequestSchema, async (request) => {\n      try {\n        const tools = await getTools();\n        const toolName = request.params.name;\n\n        if (!(toolName in tools)) {\n          throw new Error('tool not found');\n        }\n\n        const tool = tools[toolName];\n\n        if (!tool) {\n          throw new Error('tool not found');\n        }\n\n        const args = tool.parameters\n          .strict()\n          .parse(request.params.arguments ?? {});\n\n        const result = await tool.execute(args);\n        const content = result\n          ? [{ type: 'text', text: JSON.stringify(result) }]\n          : [];\n\n        return {\n          content,\n        };\n      } catch (error) {\n        return {\n          isError: true,\n          content: [\n            {\n              type: 'text',\n              text: JSON.stringify({ error: enumerateError(error) }),\n            },\n          ],\n        };\n      }\n    });\n  }\n\n  // Expand types recursively for better intellisense\n  type Request = ExpandRecursively<ExtractRequest<typeof server>>;\n  type Notification = ExpandRecursively<ExtractNotification<typeof server>>;\n  type Result = ExpandRecursively<ExtractResult<typeof server>>;\n\n  return server as Server<Request, Notification, Result>;\n}\n\nfunction enumerateError(error: unknown) {\n  if (!error) {\n    return error;\n  }\n\n  if (typeof error !== 'object') {\n    return error;\n  }\n\n  const newError: Record<string, unknown> = {};\n\n  const errorProps = ['name', 'message'] as const;\n\n  for (const prop of errorProps) {\n    if (prop in error) {\n      newError[prop] = (error as Record<string, unknown>)[prop];\n    }\n  }\n\n  return newError;\n}\n","import type { ExtractParams } from './types.js';\n\n/**\n * Asserts that a URI is valid.\n */\nexport function assertValidUri(uri: string) {\n  try {\n    new URL(uri);\n    return uri;\n  } catch {\n    throw new Error(`invalid uri: ${uri}`);\n  }\n}\n\n/**\n * Compares two URIs.\n */\nexport function compareUris(uriA: string, uriB: string): boolean {\n  const urlA = new URL(uriA);\n  const urlB = new URL(uriB);\n\n  return urlA.href === urlB.href;\n}\n\n/**\n * Matches a URI to a RFC 6570 URI Template (resourceUris) and extracts\n * the parameters.\n *\n * Currently only supports simple string parameters.\n */\nexport function matchUriTemplate<Templates extends string[]>(\n  uri: string,\n  uriTemplates: Templates\n):\n  | {\n      uri: Templates[number];\n      params: { [Param in ExtractParams<Templates[number]>]: string };\n    }\n  | undefined {\n  const url = new URL(uri);\n  const segments = url.pathname.split('/').slice(1);\n\n  for (const resourceUri of uriTemplates) {\n    const resourceUrl = new URL(resourceUri);\n    const resourceSegments = decodeURIComponent(resourceUrl.pathname)\n      .split('/')\n      .slice(1);\n\n    if (segments.length !== resourceSegments.length) {\n      continue;\n    }\n\n    const params: Record<string, string> = {};\n    let isMatch = true;\n\n    for (let i = 0; i < segments.length; i++) {\n      const resourceSegment = resourceSegments[i];\n      const segment = segments[i];\n\n      if (!resourceSegment || !segment) {\n        break;\n      }\n\n      if (resourceSegment.startsWith('{') && resourceSegment.endsWith('}')) {\n        const paramKey = resourceSegment.slice(1, -1);\n\n        if (!paramKey) {\n          break;\n        }\n\n        params[paramKey] = segment;\n      } else if (segments[i] !== resourceSegments[i]) {\n        isMatch = false;\n        break;\n      }\n    }\n\n    if (isMatch) {\n      return {\n        uri: resourceUri,\n        params: params as {\n          [Param in ExtractParams<Templates[number]>]: string;\n        },\n      };\n    }\n  }\n}\n","import type { Transport } from '@modelcontextprotocol/sdk/shared/transport.js';\nimport type { JSONRPCMessage } from '@modelcontextprotocol/sdk/types.js';\nimport type { DuplexStream } from './types.js';\n\n/**\n * An MCP transport built on top of a duplex stream.\n * It uses a `ReadableStream` to receive messages and a `WritableStream` to send messages.\n *\n * Useful if you wish to pipe messages over your own stream-based transport or directly between two streams.\n */\nexport class StreamTransport\n  implements Transport, DuplexStream<JSONRPCMessage>\n{\n  #readableStreamController?: ReadableStreamDefaultController<JSONRPCMessage>;\n  #writeableStreamController?: WritableStreamDefaultController;\n\n  ready: Promise<void>;\n\n  readable: ReadableStream<JSONRPCMessage>;\n  writable: WritableStream<JSONRPCMessage>;\n\n  onclose?: () => void;\n  onerror?: (error: Error) => void;\n  onmessage?: (message: JSONRPCMessage) => void;\n\n  constructor() {\n    let resolveReadReady: () => void;\n    let resolveWriteReady: () => void;\n\n    const readReady = new Promise<void>((resolve) => {\n      resolveReadReady = resolve;\n    });\n\n    const writeReady = new Promise<void>((resolve) => {\n      resolveWriteReady = resolve;\n    });\n\n    this.ready = Promise.all([readReady, writeReady]).then(() => {});\n\n    this.readable = new ReadableStream({\n      start: (controller) => {\n        this.#readableStreamController = controller;\n        resolveReadReady();\n      },\n    });\n\n    this.writable = new WritableStream({\n      start: (controller) => {\n        this.#writeableStreamController = controller;\n        resolveWriteReady();\n      },\n      write: (message) => {\n        this.onmessage?.(message);\n      },\n    });\n  }\n\n  async start() {\n    await this.ready;\n  }\n\n  async send(message: JSONRPCMessage) {\n    if (!this.#readableStreamController) {\n      throw new Error('readable stream not initialized');\n    }\n    this.#readableStreamController.enqueue(message);\n  }\n\n  async close() {\n    this.#readableStreamController?.error(new Error('connection closed'));\n    this.#writeableStreamController?.error(new Error('connection closed'));\n    this.onclose?.();\n  }\n}\n"],"mappings":"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","names":["Server","CallToolRequestSchema","ListResourcesRequestSchema","ListResourceTemplatesRequestSchema","ListToolsRequestSchema","ReadResourceRequestSchema","zodToJsonSchema","assertValidUri","uri","compareUris","uriA","uriB","urlA","urlB","matchUriTemplate","uriTemplates","segments","resourceUri","resourceUrl","resourceSegments","params","isMatch","i","resourceSegment","segment","paramKey","resource","uri","resourceTemplate","uriTemplate","jsonResource","jsonResourceTemplate","resources","scheme","url","jsonResourceResponse","response","tool","createMcpServer","options","capabilities","server","Server","getResources","getTools","clientInfo","clientCapabilities","initData","ListResourcesRequestSchema","name","description","mimeType","ListResourceTemplatesRequestSchema","ReadResourceRequestSchema","request","allResources","compareUris","result","resourceTemplates","resourceTemplateUris","assertValidUri","templateMatch","matchUriTemplate","r","error","enumerateError","ListToolsRequestSchema","tools","parameters","zodToJsonSchema","CallToolRequestSchema","toolName","args","newError","errorProps","prop","StreamTransport","#readableStreamController","#writeableStreamController","resolveReadReady","resolveWriteReady","readReady","resolve","writeReady","controller","message"]}