import{Server as T}from"@modelcontextprotocol/sdk/server/index.js";import{CallToolRequestSchema as S,ListResourcesRequestSchema as U,ListResourceTemplatesRequestSchema as b,ListToolsRequestSchema as P,ReadResourceRequestSchema as v}from"@modelcontextprotocol/sdk/types.js";import E from"zod-to-json-schema";function y(e){try{return new URL(e),e}catch{throw new Error(`invalid uri: ${e}`)}}function g(e,r){let o=new URL(e),n=new URL(r);return o.href===n.href}function x(e,r){let n=new URL(e).pathname.split("/").slice(1);for(let m of r){let s=new URL(m),t=decodeURIComponent(s.pathname).split("/").slice(1);if(n.length!==t.length)continue;let i={},c=!0;for(let a=0;a<n.length;a++){let u=t[a],R=n[a];if(!u||!R)break;if(u.startsWith("{")&&u.endsWith("}")){let p=u.slice(1,-1);if(!p)break;i[p]=R}else if(n[a]!==t[a]){c=!1;break}}if(c)return{uri:m,params:i}}}function I(e,r){return{uri:e,...r}}function L(e,r){return{uriTemplate:e,...r}}function z(e,r){return{uri:e,mimeType:"application/json",...r}}function J(e,r){return{uriTemplate:e,mimeType:"application/json",...r}}function M(e,r){return r.map(o=>{if("uri"in o){let s=new URL(o.uri,`${e}://`),t=decodeURI(s.href);return{...o,uri:t}}let n=new URL(o.uriTemplate,`${e}://`),m=decodeURI(n.href);return{...o,uriTemplate:m}})}function D(e,r){return{uri:e,mimeType:"application/json",text:JSON.stringify(r)}}function W(e){return e}function A(e){let r={};e.resources&&(r.resources={}),e.tools&&(r.tools={});let o=new T({name:e.name,version:e.version},{capabilities:r});async function n(){if(!e.resources)throw new Error("resources not available");return typeof e.resources=="function"?await e.resources():e.resources}async function m(){if(!e.tools)throw new Error("tools not available");return typeof e.tools=="function"?await e.tools():e.tools}return o.oninitialized=async()=>{let s=o.getClientVersion(),t=o.getClientCapabilities();if(!s)throw new Error("client info not available after initialization");if(!t)throw new Error("client capabilities not available after initialization");let i={clientInfo:s,clientCapabilities:t};await e.onInitialize?.(i)},e.resources&&(o.setRequestHandler(U,async()=>({resources:(await n()).filter(t=>"uri"in t).map(({uri:t,name:i,description:c,mimeType:a})=>({uri:t,name:i,description:c,mimeType:a}))})),o.setRequestHandler(b,async()=>({resourceTemplates:(await n()).filter(t=>"uriTemplate"in t).map(({uriTemplate:t,name:i,description:c,mimeType:a})=>({uriTemplate:t,name:i,description:c,mimeType:a}))})),o.setRequestHandler(v,async s=>{try{let t=await n(),{uri:i}=s.params,a=t.filter(l=>"uri"in l).find(l=>g(l.uri,i));if(a){let l=await a.read(i);return{contents:Array.isArray(l)?l:[l]}}let u=t.filter(l=>"uriTemplate"in l),R=u.map(({uriTemplate:l})=>y(l)),p=x(i,R);if(!p)throw new Error("resource not found");let d=u.find(l=>l.uriTemplate===p.uri);if(!d)throw new Error("resource not found");let f=await d.read(i,p.params);return{contents:Array.isArray(f)?f:[f]}}catch(t){return{isError:!0,content:[{type:"text",text:JSON.stringify({error:w(t)})}]}}})),e.tools&&(o.setRequestHandler(P,async()=>{let s=await m();return{tools:Object.entries(s).map(([t,{description:i,parameters:c}])=>({name:t,description:i,inputSchema:E(c)}))}}),o.setRequestHandler(S,async s=>{try{let t=await m(),i=s.params.name;if(!(i in t))throw new Error("tool not found");let c=t[i];if(!c)throw new Error("tool not found");let a=c.parameters.strict().parse(s.params.arguments??{}),u=await c.execute(a);return{content:u?[{type:"text",text:JSON.stringify(u)}]:[]}}catch(t){return{isError:!0,content:[{type:"text",text:JSON.stringify({error:w(t)})}]}}})),o}function w(e){if(!e||typeof e!="object")return e;let r={},o=["name","message"];for(let n of o)n in e&&(r[n]=e[n]);return r}var h=class{#e;#t;ready;readable;writable;onclose;onerror;onmessage;constructor(){let r,o,n=new Promise(s=>{r=s}),m=new Promise(s=>{o=s});this.ready=Promise.all([n,m]).then(()=>{}),this.readable=new ReadableStream({start:s=>{this.#e=s,r()}}),this.writable=new WritableStream({start:s=>{this.#t=s,o()},write:s=>{this.onmessage?.(s)}})}async start(){await this.ready}async send(r){if(!this.#e)throw new Error("readable stream not initialized");this.#e.enqueue(r)}async close(){this.#e?.error(new Error("connection closed")),this.#t?.error(new Error("connection closed")),this.onclose?.()}};export{h as StreamTransport,A as createMcpServer,z as jsonResource,D as jsonResourceResponse,J as jsonResourceTemplate,I as resource,L as resourceTemplate,M as resources,W as tool};
//# sourceMappingURL=index.js.map