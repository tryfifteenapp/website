import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { Implementation, ClientCapabilities, JSONRPCMessage } from '@modelcontextprotocol/sdk/types.js';
import { z } from 'zod';
import { Transport } from '@modelcontextprotocol/sdk/shared/transport.js';

/**
 * A web stream that can be both read from and written to.
 */
interface DuplexStream<T> {
    readable: ReadableStream<T>;
    writable: WritableStream<T>;
}
/**
 * Expands a type into its properties recursively.
 *
 * Useful for providing better intellisense in IDEs.
 */
type ExpandRecursively<T> = T extends (...args: infer A) => infer R ? (...args: ExpandRecursively<A>) => ExpandRecursively<R> : T extends object ? T extends infer O ? {
    [K in keyof O]: ExpandRecursively<O[K]>;
} : never : T;
/**
 * Extracts parameter names from a string path.
 *
 * @example
 * type Path = '/schemas/{schema}/tables/{table}';
 * type Params = ExtractParams<Path>; // 'schema' | 'table'
 */
type ExtractParams<Path extends string> = Path extends `${string}{${infer P}}${infer Rest}` ? P | ExtractParams<Rest> : never;
/**
 * Extracts the request type from an MCP server.
 */
type ExtractRequest<S> = S extends Server<infer R, any, any> ? R : never;
/**
 * Extracts the notification type from an MCP server.
 */
type ExtractNotification<S> = S extends Server<any, infer N, any> ? N : never;
/**
 * Extracts the result type from an MCP server.
 */
type ExtractResult<S> = S extends Server<any, any, infer R> ? R : never;

type Scheme = string;
type Resource<Uri extends string = string, Result = unknown> = {
    uri: Uri;
    name: string;
    description?: string;
    mimeType?: string;
    read(uri: `${Scheme}://${Uri}`): Promise<Result>;
};
type ResourceTemplate<Uri extends string = string, Result = unknown> = {
    uriTemplate: Uri;
    name: string;
    description?: string;
    mimeType?: string;
    read(uri: `${Scheme}://${Uri}`, params: {
        [Param in ExtractParams<Uri>]: string;
    }): Promise<Result>;
};
type Tool<Params extends z.ZodObject<any> = z.ZodObject<any>, Result = unknown> = {
    description: string;
    parameters: Params;
    execute(params: z.infer<Params>): Promise<Result>;
};
/**
 * Helper function to define an MCP resource while preserving type information.
 */
declare function resource<Uri extends string, Result>(uri: Uri, resource: Omit<Resource<Uri, Result>, 'uri'>): Resource<Uri, Result>;
/**
 * Helper function to define an MCP resource with a URI template while preserving type information.
 */
declare function resourceTemplate<Uri extends string, Result>(uriTemplate: Uri, resource: Omit<ResourceTemplate<Uri, Result>, 'uriTemplate'>): ResourceTemplate<Uri, Result>;
/**
 * Helper function to define a JSON resource while preserving type information.
 */
declare function jsonResource<Uri extends string, Result>(uri: Uri, resource: Omit<Resource<Uri, Result>, 'uri' | 'mimeType'>): Resource<Uri, Result>;
/**
 * Helper function to define a JSON resource with a URI template while preserving type information.
 */
declare function jsonResourceTemplate<Uri extends string, Result>(uriTemplate: Uri, resource: Omit<ResourceTemplate<Uri, Result>, 'uriTemplate' | 'mimeType'>): ResourceTemplate<Uri, Result>;
/**
 * Helper function to define a list of resources that share a common URI scheme.
 */
declare function resources<Scheme extends string>(scheme: Scheme, resources: (Resource | ResourceTemplate)[]): (Resource<`${Scheme}://${string}`> | ResourceTemplate<`${Scheme}://${string}`>)[];
/**
 * Helper function to create a JSON resource response.
 */
declare function jsonResourceResponse<Uri extends string, Response>(uri: Uri, response: Response): {
    uri: Uri;
    mimeType: string;
    text: string;
};
/**
 * Helper function to define an MCP tool while preserving type information.
 */
declare function tool<Params extends z.ZodObject<any>, Result>(tool: Tool<Params, Result>): Tool<Params, Result>;
type InitData = {
    clientInfo: Implementation;
    clientCapabilities: ClientCapabilities;
};
type InitCallback = (initData: InitData) => void | Promise<void>;
type PropCallback<T> = () => T | Promise<T>;
type Prop<T> = T | PropCallback<T>;
type McpServerOptions = {
    /**
     * The name of the MCP server. This will be sent to the client as part of
     * the initialization process.
     */
    name: string;
    /**
     * The version of the MCP server. This will be sent to the client as part of
     * the initialization process.
     */
    version: string;
    /**
     * Callback for when initialization has fully completed with the client.
     */
    onInitialize?: InitCallback;
    /**
     * Resources to be served by the server. These can be defined as a static
     * object or as a function that dynamically returns the object synchronously
     * or asynchronously.
     *
     * If defined as a function, the function will be called whenever the client
     * asks for the list of resources or reads a resource. This allows for dynamic
     * resources that can change after the server has started.
     */
    resources?: Prop<(Resource<string, unknown> | ResourceTemplate<string, unknown>)[]>;
    /**
     * Tools to be served by the server. These can be defined as a static object
     * or as a function that dynamically returns the object synchronously or
     * asynchronously.
     *
     * If defined as a function, the function will be called whenever the client
     * asks for the list of tools or invokes a tool. This allows for dynamic tools
     * that can change after the server has started.
     */
    tools?: Prop<Record<string, Tool>>;
};
/**
 * Creates an MCP server with the given options.
 *
 * Simplifies the process of creating an MCP server by providing a high-level
 * API for defining resources and tools.
 */
declare function createMcpServer(options: McpServerOptions): Server<{
    method: string;
    params?: {
        [x: string]: unknown;
        _meta?: {
            [x: string]: unknown;
            progressToken?: string | number | undefined;
        } | undefined;
    } | undefined;
}, {
    method: string;
    params?: {
        [x: string]: unknown;
        _meta?: {
            [x: string]: unknown;
        } | undefined;
    } | undefined;
}, {
    [x: string]: unknown;
    _meta?: {
        [x: string]: unknown;
    } | undefined;
}>;

/**
 * An MCP transport built on top of a duplex stream.
 * It uses a `ReadableStream` to receive messages and a `WritableStream` to send messages.
 *
 * Useful if you wish to pipe messages over your own stream-based transport or directly between two streams.
 */
declare class StreamTransport implements Transport, DuplexStream<JSONRPCMessage> {
    #private;
    ready: Promise<void>;
    readable: ReadableStream<JSONRPCMessage>;
    writable: WritableStream<JSONRPCMessage>;
    onclose?: () => void;
    onerror?: (error: Error) => void;
    onmessage?: (message: JSONRPCMessage) => void;
    constructor();
    start(): Promise<void>;
    send(message: JSONRPCMessage): Promise<void>;
    close(): Promise<void>;
}

export { type DuplexStream, type ExpandRecursively, type ExtractNotification, type ExtractParams, type ExtractRequest, type ExtractResult, type InitCallback, type InitData, type McpServerOptions, type Prop, type PropCallback, type Resource, type ResourceTemplate, type Scheme, StreamTransport, type Tool, createMcpServer, jsonResource, jsonResourceResponse, jsonResourceTemplate, resource, resourceTemplate, resources, tool };
